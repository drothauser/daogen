/*
 * (c) 2015 Rothsmith, LLC, All Rights Reserved
 * 
 * Source code generated by Fluent Builders ArtifactGenerator Do not modify this
 * file See generator home page at:
 * http://code.google.com/p/fluent-builders-generator-eclipse-plugin/
 */
// CHECKSTYLE:OFF
package com.rothsmith.dao.core;

// CHECKSTYLE:ON

import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Fluent builder for building an instance of {@link Params}.
 * 
 * @author drothauser
 *
 * @param <T>
 */
@SuppressWarnings("PMD")
class ParamsBuilderBase<T extends ParamsBuilderBase<T>> {

	/**
	 * Default Velocity template for generating data transfer objects.
	 */
	public static final String DAO_DEFINITIONS_TEMPLATE = "/daodefs.vm";

	/**
	 * Default Velocity template for generating data transfer objects.
	 */
	public static final String DTO_DEFAULT_TEMPLATE = "/dto.vm";

	/**
	 * Instance of {@link Params}.
	 */
	private Params instance;

	/**
	 * Construct {@link ParamsBuilderBase} with the given {@link Params} object.
	 * 
	 * @param params
	 *            {@link Params} object.
	 */
	protected ParamsBuilderBase(Params params) {
		instance = params;
	}

	/**
	 * Retrieve the instance of {@link Params} to be built.
	 * 
	 * @return {@link Params}
	 */
	protected Params getInstance() {
		return instance;
	}

	/**
	 * Set the full path and name for the generated DAO definitions file.
	 * 
	 * @param defFile
	 *            fully qualified name for the generated DAO definitions file.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDefFile(String defFile) {
		instance.setDefFile(defFile);

		return (T) this;
	}

	/**
	 * Set the DAO definitions template file.
	 * 
	 * @param defTemplate
	 *            Velocity template file used to generate the DAO definitions
	 *            file. The template file is expected to be in the classpath.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDefFileTemplate(String defTemplate) {
		instance.setDefFileTemplate(
		    StringUtils.defaultIfBlank(defTemplate, DAO_DEFINITIONS_TEMPLATE));

		return (T) this;
	}

	/**
	 * set the package for the generated DTO classes.
	 * 
	 * @param dtoPackageName
	 *            The package for the generated DTO classes
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDtoPackageName(String dtoPackageName) {
		instance.setDtoPackageName(dtoPackageName);

		return (T) this;
	}

	/**
	 * Set the DtoTemplate file.
	 * 
	 * @param dtoTemplate
	 *            Velocity template file used to generate DTOs. The template
	 *            file is expected to be in the classpath.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDtoTemplate(String dtoTemplate) {

		instance.setDtoTemplate(
		    StringUtils.defaultIfBlank(dtoTemplate, DTO_DEFAULT_TEMPLATE));

		return (T) this;
	}

	/**
	 * Set the Velocity template file used to generate JUnit test classes.
	 * 
	 * @param junitTemplate
	 *            Velocity template file used to generate JUnit test classes.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withJunitTemplate(String junitTemplate) {
		instance.setJunitTemplate(junitTemplate);

		return (T) this;
	}

	/**
	 * Set the directory for the the generated DAO artifacts.
	 * 
	 * @param outputDir
	 *            the directory for the the generated DAO artifacts.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withOutputDir(String outputDir) {
		instance.setOutputDir(outputDir);

		return (T) this;
	}

	/**
	 * Set the DAO properties file. The DAO properties file contains things like
	 * connection parameters.
	 * 
	 * @param propsFile
	 *            the DAO properties file
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withPropsFile(String propsFile) {
		instance.setPropsFile(propsFile);

		return (T) this;
	}

	/**
	 * Set the database schema name.
	 * 
	 * @param schema
	 *            the database schema name
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withSchema(String schema) {
		instance.setSchemaPattern(schema);

		return (T) this;
	}

	/**
	 * Set the full path and name of the generated Spring application context
	 * file (the file name is usually something like
	 * &quot;applicationContext.xml&quot;).
	 * 
	 * @param springAppCtxFile
	 *            the fully qualified name of the generated Spring application
	 *            context file.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withSpringAppCtxFile(String springAppCtxFile) {
		instance.setSpringAppCtxFile(springAppCtxFile);

		return (T) this;
	}

	/**
	 * Sets the Velocity template file used to generate a Spring context file.
	 * 
	 * @param springAppCtxTemplate
	 *            the Velocity template file used to generate a Spring context
	 *            file
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withSpringAppCtxTemplate(String springAppCtxTemplate) {
		instance.setSpringAppCtxTemplate(springAppCtxTemplate);

		return (T) this;
	}

	/**
	 * Sets the The name of the generated Spring DAO bean context file. This
	 * context file gets included in the main Spring application context file.
	 * 
	 * @param springDaoCtxFile
	 *            the name of the generated Spring DAO bean context file.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withSpringDaoCtxFile(String springDaoCtxFile) {
		instance.setSpringDaoCtxFile(springDaoCtxFile);

		return (T) this;
	}

	/**
	 * The Velocity template file used to generate Spring DAO bean context file.
	 * 
	 * @param springDaoCtxTemplate
	 *            the Velocity template file used to generate Spring DAO bean
	 *            context file.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withSpringDaoCtxTemplate(String springDaoCtxTemplate) {
		instance.setSpringDaoCtxTemplate(springDaoCtxTemplate);

		return (T) this;
	}

	/**
	 * Sets a list of one or more SQL statements delimited by a semicolon.
	 * 
	 * @param sqlStmts
	 *            a list of one or more SQL statements delimited by
	 *            &quot;;&quot;
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withSqlStmts(String sqlStmts) {
		instance.setSqlStmts(sqlStmts);

		return (T) this;
	}

	/**
	 * Sets the table related object names to generate DAOs for. These could be
	 * tables, views or synonyms.
	 * 
	 * @param tableNames
	 *            the object names to generate DAOs for
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withTableNames(String tableNames) {
		instance.setTableNames(tableNames);

		return (T) this;
	}

	/**
	 * Sets the table related object types used to filter object names.
	 * 
	 * @param tableTypes
	 *            the table related object types used to filter object names
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withTableTypes(String tableTypes) {
		instance.setTableTypes(tableTypes);

		return (T) this;
	}

	/**
	 * Sets the directory for the the generated DAO artifacts.
	 * 
	 * @param testOutputDir
	 *            the directory for the the generated DAO artifacts
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withTestOutputDir(String testOutputDir) {
		instance.setTestOutputDir(testOutputDir);

		return (T) this;
	}

	/**
	 * Sets the package name for Junit test classes.
	 * 
	 * @param testPackageName
	 *            the package name for Junit test classes
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withTestPackageName(String testPackageName) {
		instance.setTestPackageName(testPackageName);

		return (T) this;
	}

	/**
	 * Sets the JDBC URL.
	 * 
	 * @param jdbcURL
	 *            the JDBC URL
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withJdbcURL(String jdbcURL) {
		instance.setJdbcURL(jdbcURL);

		return (T) this;
	}

	/**
	 * Set the database username.
	 * 
	 * @param username
	 *            user id used to access the database.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDbUsername(String username) {
		instance.setDbUsername(username);

		return (T) this;
	}

	/**
	 * Set the database password.
	 * 
	 * @param password
	 *            password used to access the database.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDbPassword(String password) {
		instance.setDbPassword(password);

		return (T) this;
	}

	/**
	 * Sets the JDBC driver class name.
	 * 
	 * @param jdbcDriverClassName
	 *            the JDBC driver class name
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withJdbcDriverClassName(String jdbcDriverClassName) {
		instance.setJdbcDriverClassName(jdbcDriverClassName);

		return (T) this;
	}

	/**
	 * Sets the Velocity template used for generating DbUtils DAO properties
	 * file.
	 * 
	 * @param dbUtilsPropsTemplate
	 *            the Velocity template used for generating DbUtils DAO
	 *            properties file
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDbUtilsPropsTemplate(String dbUtilsPropsTemplate) {
		instance.setDbUtilsPropsTemplate(dbUtilsPropsTemplate);

		return (T) this;
	}

	/**
	 * Set the directory that will contain database properties files used by
	 * DbUtils DAOs.
	 * 
	 * @param propsDir
	 *            the directory that contains database properties files used by
	 *            DbUtils DAOs.
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withDbUtilsPropsDir(String propsDir) {
		instance.setDbUtilsPropsDir(propsDir);

		return (T) this;
	}

	/**
	 * Sets the JNDI name of the JDBC datasource (for example
	 * java:/comp/env/jdbc/TestDS)
	 * 
	 * @param jndiName
	 *            the JNDI name of the JDBC datasource
	 * @return {@link ParamsBuilder}
	 */
	@SuppressWarnings("unchecked")
	public T withJndiName(String jndiName) {
		// TODO - Make mutually exclusive with dbUsername and dbPassword
		instance.setJndiName(jndiName);

		return (T) this;
	}

}

/**
 * Fluent Builder for {@link Params}.
 * 
 * @author drothauser
 *
 */
@SuppressWarnings("PMD")
public final class ParamsBuilder
        extends
        ParamsBuilderBase<ParamsBuilder> {

	/**
	 * SLF4J Logger for ParamsBuilder.
	 */
	private static final Logger LOGGER =
	    LoggerFactory.getLogger(ParamsBuilder.class);

	/**
	 * Create a new instance of {@link ParamsBuilder}.
	 * 
	 * @return a new instance of {@link ParamsBuilder}
	 */
	public static ParamsBuilder newInstance() {
		return new ParamsBuilder();
	}

	/**
	 * Default constructor.
	 */
	private ParamsBuilder() {
		super(new Params());
	}

	/**
	 * Returns the {@link Params} that was set up by this {@link ParamsBuilder}.
	 * 
	 * @return the instance of {@link Params} that was built by
	 *         {@link ParamsBuilder}.
	 */
	public Params build() {
		Params params = getInstance();

		validate(params);

		return params;
	}

	/**
	 * Validate the {@link Params} object.
	 * 
	 * @param params
	 *            the instance of {@link Params} to validate
	 * @throws IllegalArgumentException
	 *             if one or more parameters fail validation
	 */
	private void validate(Params params) {
		ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
		Validator validator = factory.getValidator();
		Set<ConstraintViolation<Params>> violations =
		    validator.validate(params);
		if (!violations.isEmpty()) {
			StringBuilder sb = new StringBuilder();
			// CHECKSTYLE:OFF CheckStyle doesn't handle lambdas yet
			violations.forEach(violation -> {
				sb.append(String.format("%n%s is invalid (value = '%s'): %s",
				    violation.getPropertyPath(), violation.getInvalidValue(),
				    violation.getMessage()));
			});
			// CHECKSTYLE:ON
			String errors = sb.toString();
			LOGGER.error(errors);
			throw new IllegalArgumentException(errors);
		}
	}
}
